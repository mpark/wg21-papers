---
title: "Pattern Matching: Customization Point for Open Sum Types"
document: D3521R0
date: today
audience:
  - Evolution
  - Library Evolution
author:
  - name: Michael Park
    email: <mcypark@gmail.com>
  - name: Zach Laine
    email: <whatwasthataddress@gmail.com>
toc: true
toc-depth: 4
---

# Introduction

This is an accompanying paper for [@P2688R3] with respect to customization points
in the library. At the Wrocław meeting in November 2024, the following poll was
taken in EWG:

> Poll: [@P2688R3] — Pattern Matching: `match` Expression, we encourage more work
> on the language-only paper towards C++26 in the next meeting (note: voting
> against this poll does not exclude getting pattern matching in C++29)
>
> Result: SF: 17, F: 16, N: 6, A: 1, SA: 9

The "language-only paper" still relies on library facilities, the same way that
structured bindings is a "language-only" feature that relies on library facilities
as a hook for customization.

A [Reflection-based Tuple-like and Variant-like Customization Points] has been
explored, but the design decision for [@P2688R3] targeting C++26 is to use
the existing facilities.

[Reflection-based Tuple-like and Variant-like Customization Points]: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r3.html#reflection-based-tuple-like-and-variant-like-customization-points

This makes it such that even a "language-only paper" is plenty useful without
any library changes. However, there is one customization point that is currently
missing: the ability for user-defined types to opt-in as an open sum type.

This paper proposes to add that customization point.

# Motivation and Scope

## Sum Types

First, definitions.  A "sum type" `SUM` is a type that represents one of
several types in the set `S` = {`T0`, `T1`, ... `TN`}.  Which `Ti` `SUM`
represents is a runtime property.

The set of types `S` is part of the definition of `SUM`, but the exact
elements of `S` might not be known at the time `SUM` is defined.  For
instance: for `std::variant<int, double>`, `S` = `{int, double}`; however, for
`std::any`, `S` = `{x | x is a copyable C++ type}`.  Though we know that
`std::any` can hold any copyable type, we don't know all the copyable types
that might exist in a program.

If all the elements `S` are known at the time that `SUM` is defined, we say
that `SUM` is a "closed" sum type (e.g. `std::variant<int, double>`).  If the
members of the set are *not* known at the time `SUM` is defined, we say that
`SUM` is an "open" sum type (e.g. `std::any`).

## Implications for Pattern Matching

[@P2688R3] proposes an alternative pattern which has syntax like the following:

```cpp
int f(const std::variant<int, double>& v) {
  return v match {
    int: let i => i;
    double: let d => int(d);
  };
}
```

This uses the "variant-like" protocol which uses the existing set of variant
helpers: `variant_size`, `variant_alternative`, `get`, and `index`.

For open sum types however, there is no such existing facility.
`std::any` and `std::exception_ptr` are examples of such types.

::: cmptable

### C++23

```cpp
int f(const std::any& a) {
  if (auto* i = std::any_cast<int>(&a)) {
    return *i;
  } else if (auto* d = std::any_cast<double>(&a)) {
    return *d;
  } else {
    return -1;
  }
}
```

### P2688 with This Paper

```cpp
int f(const std::any& a) {
  return a match -> int {
    int: let i => i;
    double: let d => d;
    _ => -1;
  };
}
```

:::

[@P2927R2] mentions a desired pattern matching use case for `std::exception_ptr`.
The example is written with [@P1371R3], but the following is what it would look
like with [@P2688R3]:

::: cmptable

### C++23

```cpp
void f(const std::exception_ptr& eptr) {
  if (auto* e = std::exception_ptr_cast<logic_error>(eptr)) {
    // use `*e`
  } else if (auto* e = std::exception_ptr_cast<exception>(eptr)) {
    // use `*e`
  } else if (ep == nullptr) {
    std::print("no exception");
  } else {
    std::print("some other exception");
  }
}
```

### P2688 with This Paper

```cpp
void f(const std::exception_ptr& eptr) {
  eptr match {
    logic_error: let e => // use `e`
    exception: let e => // use `e`
    nullptr => std::print("no exception");
    _ => std::print("some other exception");
  };
}
```

:::

This paper proposes `try_cast` as the customization point that pattern matching
invokes to test and extract the state of open sum types.

# Design Overview

The [Alternative Pattern] as proposed in [@P2688R3] considers the following 3 cases in order:

  1. Variant-like
  2. Casts
  3. Polymorphic types

[Alternative Pattern]: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r3.html#alternative-pattern

This is modeled similarly to structured bindings protocol, which considers
the following 3 cases:

  1. Array
  2. Tuple-like
  3. Aggregate types

The cast protocol is the only one that is missing today.

The proposal is to add a CPO `try_cast` that handles: casts of `std::any`
using `any_cast`; casts of `std::exception_ptr` using `exception_ptr_cast`
from P2927R2; and casts of user-defined types using calls to `try_cast` found
via ADL, such as:

```cpp
namespace ns {
  struct Widget { /* ... */ };

  template <typename T>
  const T* try_cast(const Widget& w) noexcept {
    return // ...
  };
}
```

## How does pattern matching actually use this?

Given an example like:

```cpp
@*subject*@ match {
  @*type*@: @*subpattern*@ => // ...;
  _ => // ...;
};
```

Conceptually: `try_cast<@*type*@>(@*subject*@)` is invoked, which returns an
optional result that can be tested and dereferenced to match the *subpattern*.

More precisely: Let `E` be
`std::try_cast<std::remove_cv_t<@*type*@>>(@*subject*@)`.  The match succeeds
if and only if: `E` is well-formed; `E` is implicitly convertible to
`@*type*@`; `E` contextually converts to `true`; and
`std::forward_like<decltype(@*subject*@)>(*__temp)` matches *subpattern*.

# Proposed Wording

### Insert after `[utility.unreachable]` in header `<utilities>` synopsis ([utility.syn]{.sref}):

```diff
+ // [utility.try_cast], `try_cast`
+ template<class T>
+   requires same_as<T, remove_cvref_t<T>>
+     constexpr @*unspecified*@ try_cast = @*unspecified*@;
```

### Append to [utility]{.sref}:

::: add
???.?.? `try_cast`                                   [utility.try_cast]

[1]{.pnum} The name `try_cast` denotes a customization point object ([customization.point.object]).

[2]{.pnum} Given a subexpression `E` with type `U`, let `u` be an lvalue that denotes the reified object for `E`. Then:

 - [2.1]{.pnum} If `E` is an rvalue, `try_cast(E)` is ill-formed.

 - [2.2]{.pnum} Otherwise, if `same_as<remove_cvref_t<U>, any>` is `true` ([any]), then `try_cast(E)` is expression-equivalent to `any_cast<T>(&u)` if that is well-formed, and is ill-formed otherwise.

 - [2.3]{.pnum} Otherwise, if `same_as<remove_cvref_t<U>, exception_ptr>` is `true` ([propagation]), then `try_cast(E)` is expression-equivalent to `exception_ptr_cast<T>(&u)` if that is well-formed, and is ill-formed otherwise.

 - [2.4]{.pnum} Otherwise, if `U` is a class type and `auto(try_cast(u))` is a valid expression whose type is `T *` or `const T *`, where the meaning of `try_cast` is established as-if by performing argument-dependent lookup only ([basic.lookup.argdep]), then `try_cast(E)` is expression-equivalent to that expression.

 - [2.5]{.pnum} Otherwise, `try_cast(E)` is ill-formed.

[2.6]{.pnum} [Note: Whenever `try_cast(E)` is a valid expression, its type is `T *` or `const T *`. — end note]
:::


# Design Alternatives

## Overload `any_cast`

Adding new overloads of `any_cast` was considered as a way to opt-in as
an any-like type. Effectively designating variant-like as the closed sum type
opt-in, and any-like as the open sum type opt-in.

The reason this approach is not taken is purely technical. The current overloads
of `any_cast` include versions that takes `any` by reference. Since `any` is
implicitly constructible from anything, testing the validity of `any_cast` is
virtually always true.

## Define a `try_cast` Overload Set

This was considered initially, but it has a serious drawback.  Any new
type-erasing templates added to the standard that take template parameters
will have ADL problems.  Note that neither `std::any` nor `std::exception_ptr`
falls into this category -- neither is a template.  However, SG9 is looking to
add a `ranges::views::any_view` template.  It got nearly unanimous support at
the Wrocław 2024 meeting.  It's first template parameter its `class Type`.
`Type` may be a user-defined type, meaning that arbitrarly many other
overloads of `try_cast` may get pulled into the overload set via ADL.
Avoiding this issue is exactly why we have CPOs.

## Use a `std::hash`-like Approach

This approach is to make `try_cast` be a class template that users specialize,
rather than a CPO.

```cpp
namespace std {
  template <typename>
  struct try_cast; // undefined

  template <>
  struct try_cast<std::any> {
    template <typename T>
    static const T* to(const std::any& a) noexcept {
      return std::any_cast<T>(&a);
    }

    template <typename T>
    static T* to(std::any& a) noexcept {
      return std::any_cast<T>(&a);
    }
  };

  template <>
  struct try_cast<std::exception_ptr> {
    template <typename T>
    static const T* to(const std::exception_ptr& p) noexcept {
      return std::exception_ptr_cast<T>(p); // P2927R2
    }
  };
}
```

This allows the parameters to become references again. There are two downsides
of this approach:

  1. The user-defined type needs to re-open the `std` namespace in order to
     provide the specialization.
  2. The API becomes `std::try_cast<From>::to<To>(from)`, compared to
     the proposed API which would be simply `try_cast<To>(from)`.
